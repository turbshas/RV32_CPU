- Branch predictor
- Privileges
- Interrupts
  - especially w/ dynamic scheduling in mind
  - Exceptions carried forward until they reach M stage
  - Interrupts received in M stage
  - If control logic sees exception, don't do datapath logic - just pass exception forward
- Multiplication/divide instructions (M extension)
  - MUL/MULH[S][U]/MULW
  - MULH followed by MUL should only do 1 multiplication
  - Bunch of DIV stuff as well
- Cache:
  - Write back, write allocate
  - Cache prediction
  - Cache coherency:
    - MOESI probably
    - Directory based probably
- Virtual memory:
  - TLB
  - Physical tag, virtual index
  - 4K pages?
- SMT at some point
- Maybe some amount of superscalar
- Register renaming
- Dynamic scheduling (MIPS R10K style):
  - IF, DS, IS, EX, CM, RT
  - Reorder buffer
  - Mem order buffer
- For taken branches and unconditional jumps, generate exception if target misaligned (do not do so on branch that isn't taken)
- May want to have exception for load into x0
- Support misaligned data memory access?
- Instructions:
  - FENCE (device Input, device Output, memory Reads, memory Writes)
    - Memory model: program-order for local hart, relaxed constraints across all harts - FENCE required to enforce ordering
    - Sync data across all harts: no instruction after the fence can execute before an instruction preceding the fence
    - rs1, rd, and immediate unused
  - FENCE.I (sync instruction and data streams)
    - This only tells the local core to read all of its own writes to instructions - i.e. flush cache and pipeline
    - To sync across all harts, do a FENCE and then tell each core to do FENCE.I
    - rs1, rd, and immediate unused
  - CSR:
    - If rd = x0, no read is performed and no side effects that would occur from a read
    - If rs1 = x0, no write is performed and no side effects that would occur from a write (including illegal instruction exception on read-only CSR)
    - Requires cycle-counting register, real-time-counting register, and instruction retired-counting register
    - CSRRW
    - CSRRS
    - CSRRC
    - CSRRWI
    - CSRRSI
    - CSRRCI
  - ECALL
    - Essentially, supervisor call
    - rs1 is argument passed to system function
    - rd is return value
  - EBREAK

Priority things to do:
- RV32I instructions
- Interrupts
- Cache
- Virtual memory
- Branch Predictor
- Privileges
